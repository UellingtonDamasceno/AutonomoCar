package controllers.frontend;import facade.FacadeBackend;import facade.FacadeFrontend;import java.io.IOException;import java.net.URL;import java.util.ResourceBundle;import java.util.logging.Level;import java.util.logging.Logger;import javafx.application.Platform;import javafx.event.ActionEvent;import javafx.fxml.FXML;import javafx.fxml.Initializable;import javafx.scene.control.Button;import javafx.scene.control.Label;import javafx.scene.image.Image;import javafx.scene.image.ImageView;import javafx.scene.input.MouseEvent;import javafx.scene.layout.BorderPane;import javafx.scene.layout.ColumnConstraints;import javafx.scene.layout.GridPane;import javafx.scene.layout.RowConstraints;import javafx.scene.layout.VBox;import javafx.scene.paint.Color;import javafx.scene.shape.Circle;import model.City;import model.NullRoad;import model.Road;import model.Vertex;import model.exceptions.VertexNotExistException;import util.Point;import util.Settings.ActionBuilder;import util.Settings.Scenes;import util.Settings.SpritesCity;/** * FXML Controller class * * @author uellington */public class BuilderController implements Initializable {    @FXML    private Label lblCoordinates;    @FXML    private GridPane gridPane;    @FXML    private VBox vboxRoadsTypes;    @FXML    private VBox vboxButtons;    @FXML    private Button cancel;    @FXML    private Button btnSave;    @FXML    private BorderPane borderPane;    @FXML    private Label lblSelectedItem;    @FXML    private Label lblBertexSize;    @FXML    private Label lblEdgeSize;    @FXML    private Label lblNullRoadSize;    @FXML    private Label lblPosX;    @FXML    private Label lblPosY;    @FXML    private Label lblAdjacentSize;    private SpritesCity selectedSprite;    private ActionBuilder action;    private ImageView[][] images;    private SpritesCity[][] sprites;    private City city;    private int dRow, dy;    private int dCol, dx;    @FXML    private Label lblRoadType;    @FXML    private VBox vboxSelectedRoadInfo;    @FXML    private Label lblp1;    @FXML    private Label lblp2;    @FXML    private Label lblp3;    @FXML    private Label lblp4;    @Override    public void initialize(URL url, ResourceBundle rb) {        gridPane.getRowConstraints().clear();        gridPane.getColumnConstraints().clear();        this.city = FacadeBackend.getInstance().getCity();        this.dx = FacadeBackend.getInstance().getCityDimensionX();        this.dy = FacadeBackend.getInstance().getCityDimensionY();        gridPane.setPrefHeight(FacadeBackend.getInstance().getCityHeight());        gridPane.setPrefWidth(FacadeBackend.getInstance().getCityWidth());        dRow = (int) (gridPane.getPrefHeight() / dy);        dCol = (int) (gridPane.getPrefWidth() / dx);        this.selectedSprite = SpritesCity.NULL_ROAD;        this.action = ActionBuilder.SELECT;        this.addNColumns(dx);        this.addNRows(dy);        this.initialize(selectedSprite, dx, dy);        this.loadRoadTypes();        this.lblSelectedItem.setText("Selected: " + selectedSprite);        this.lblNullRoadSize.setText("Nº of NullRoad: " + (dx * dy));    }    @FXML    private void setDefaultCoordinates(MouseEvent event) {        lblCoordinates.setText("X = 0 :: Y = 0");    }    @FXML    private void clicked(MouseEvent event) {        int y = (int) (event.getY() / dRow);        int x = (int) (event.getX() / dCol);        switch (this.action) {            case PUT:                SpritesCity oldSprite = this.sprites[x][y];                if (oldSprite != selectedSprite) {                    Road r = this.putRoad(oldSprite, selectedSprite, x, y);                    this.updateinfo(x, y);                    this.putSectorPoints(r);                }                break;            case ROTATE_LEFT:                this.images[x][y].setRotate(this.images[x][y].getRotate() - 90);                break;            case ROTATE_RIGHT:                this.images[x][y].setRotate(this.images[x][y].getRotate() + 90);                break;            case SELECT:                this.updateinfo(x, y);                break;            default:                event.consume();                break;        }    }    private void updateinfo(int x, int y) {        Road road = this.city.getRoad(x, y);        if (road != null) {            lblBertexSize.setText("Nº of vertex: " + city.getGraph().verticesSize());            lblEdgeSize.setText("Nº of Edges: " + city.getGraph().edgesSize());            lblPosX.setText("X: " + x);            lblPosY.setText("Y: " + y);            lblNullRoadSize.setText("Nº of NullRoad: " + this.city.numNullRoad());            lblRoadType.setText(road.getType());            try {                Vertex vertex = this.city.getGraph().getVertex(road);                this.lblAdjacentSize.setText("Adjacencies: " + vertex.degree());            } catch (VertexNotExistException ex) {                this.lblAdjacentSize.setText("Vertex not exist!");            }            this.lblp1.setText(road.getSectors()[0].toString());            this.lblp2.setText(road.getSectors()[1].toString());            this.lblp3.setText(road.getSectors()[2].toString());            this.lblp4.setText(road.getSectors()[3].toString());        }    }    @FXML    private void updateCoordinates(MouseEvent event) {        lblCoordinates.setText("X = " + event.getX() + " :: " + "Y = " + event.getY());    }    @FXML    private void cancelEditing(ActionEvent event) {        try {            FacadeFrontend.getInstance().changeScreean(Scenes.BUILDER_SETTINGS);        } catch (Exception ex) {            Logger.getLogger(BuilderController.class.getName()).log(Level.SEVERE, null, ex);        }    }    @FXML    private void save(ActionEvent event) {        try {            FacadeBackend.getInstance().save();            FacadeFrontend.getInstance().changeScreean(Scenes.MAIN);        } catch (IOException ex) {            Logger.getLogger(BuilderController.class.getName()).log(Level.SEVERE, null, ex);        } catch (Exception ex) {            Logger.getLogger(BuilderController.class.getName()).log(Level.SEVERE, null, ex);        }    }    private void initialize(SpritesCity initialSprite, int dx, int dy) {        this.images = new ImageView[dx][dy];        this.sprites = new SpritesCity[dx][dy];        ImageView imageView;        Image image = new Image(initialSprite.get());        for (int i = 0; i < dx; i++) {            for (int j = 0; j < dy; j++) {                imageView = new ImageView(image);                imageView.setFitHeight(dRow);                imageView.setFitWidth(dCol);                this.images[i][j] = imageView;                this.sprites[i][j] = initialSprite;                this.gridPane.add(imageView, i, j);            }        }    }    private void loadRoadTypes() {        ImageView imageView;        Image image;        Label options;        for (SpritesCity sprite : SpritesCity.values()) {            if (sprite != SpritesCity.NULL_ROAD) {                image = new Image(sprite.get());                imageView = new ImageView(image);                imageView.setFitHeight(50);                imageView.setFitWidth(50);                options = new Label(sprite.name(), imageView);                options.setOnMouseClicked((MouseEvent event) -> {                    if (selectedSprite != null && selectedSprite != sprite) {                        BuilderController.this.selectedSprite = sprite;                        action = ActionBuilder.PUT;                        this.lblSelectedItem.setText("Selected: " + sprite.get());                    }                });                this.vboxRoadsTypes.getChildren().add(options);            }        }    }    private void addNColumns(int columns) {        ColumnConstraints col;        for (int i = 0; i < columns; i++) {            col = new ColumnConstraints();            col.setMinWidth(dCol);            this.gridPane.getColumnConstraints().add(col);        }    }    private void addNRows(int rows) {        RowConstraints row;        for (int i = 0; i < rows; i++) {            row = new RowConstraints();            row.setMinHeight(dRow);            this.gridPane.getRowConstraints().add(row);        }    }    @FXML    private void rotateLess(ActionEvent event) {        this.action = ActionBuilder.SELECT;    }    @FXML    private void rotateMore(ActionEvent event) {        this.action = ActionBuilder.ROTATE_RIGHT;    }    private Road putRoad(SpritesCity oldSprite, SpritesCity newSprite, int x, int y) {        ImageView imageView = this.images[x][y];        Image image = new Image(newSprite.get());        Road road = new NullRoad(x, y);        if ((newSprite.isRoad() && oldSprite.isRoad())                || (!newSprite.isRoad() && !oldSprite.isRoad())) {            FacadeBackend.getInstance().updateSprite(newSprite.get(), x, y);        } else if (oldSprite.isRoad() && !(newSprite.isRoad())) {            FacadeBackend.getInstance().removeRoad(x, y);            FacadeBackend.getInstance().updateSprite(newSprite.get(), x, y);        } else if (!oldSprite.isRoad() && newSprite.isRoad()) {            road = FacadeBackend.getInstance().putRoad(newSprite.get(), x, y);        } else {            System.out.println("Nada acontece");        }        imageView.setImage(image);        imageView.setRotate(0);        this.sprites[x][y] = newSprite;        return road;    }    private void putSectorPoints(Road r) {        if (r != null) {            for (Point p : r.getSectors()) {                Circle circle = new Circle(p.getX(), p.getY(), 5, Color.DARKORCHID);                circle.setTranslateX(p.getX());                circle.setTranslateY(p.getY());                this.gridPane.getChildren().add(circle);            }        } else {            System.err.println("Atualizou o sprite e não retornou uma NullRoad");        }    }}